<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ORACLE拆分字符串函数应用</title>
      <link href="/2023/03/23/ORACLE%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8/"/>
      <url>/2023/03/23/ORACLE%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ORACLE中拆分字符串中的键值对应用"><a href="#ORACLE中拆分字符串中的键值对应用" class="headerlink" title="ORACLE中拆分字符串中的键值对应用"></a>ORACLE中拆分字符串中的键值对应用</h2><blockquote><p>业务场景：设备A的多个端口数据通过键值对的方式传入，需要对其不同端口的指标值进行汇聚操作，因为历史遗留问题+使用场景较少JAVA入库不想写对应模板拆分 只能用数据库来操作啦🤣🤣</p></blockquote><p>涉及的两个表：入库表：DEMO1，拆分数据后的中间表 DEMO1_MID<br>表结构和样例数据如下：<br>DEMO1:</p><table><thead><tr><th align="center">KEY_P</th><th align="center">KPI_1</th><th align="center">KPI_2</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">INDEX_1,10;INDEX_2,20;</td><td align="center">INDEX_3,30;</td></tr><tr><td align="center">B</td><td align="center">INDEX_4,40;</td><td align="center">INDEX_5,50;INDEX_6,60;</td></tr></tbody></table><p>DEMO1_MID:</p><table><thead><tr><th align="center">KEY_P</th><th align="center">KEY_</th><th align="center">VALUE</th></tr></thead></table><h3 id="1-首先要把字段进行拆分"><a href="#1-首先要把字段进行拆分" class="headerlink" title="1.首先要把字段进行拆分"></a>1.首先要把字段进行拆分</h3><p>拆分函数：split_key_value_pairs</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> split_key_value_pairs(</span><br><span class="line">    input_string <span class="keyword">IN</span> VARCHAR2,</span><br><span class="line">    delimiter <span class="keyword">IN</span> VARCHAR2 <span class="keyword">DEFAULT</span> <span class="string">&#x27;;&#x27;</span>,</span><br><span class="line">    key_value_delimiter <span class="keyword">IN</span> VARCHAR2 <span class="keyword">DEFAULT</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">) <span class="keyword">RETURN</span> SYS_REFCURSOR</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">    output_cursor SYS_REFCURSOR;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">OPEN</span> output_cursor <span class="keyword">FOR</span></span><br><span class="line">        <span class="keyword">SELECT</span> SUBSTR(input_string, <span class="number">1</span>, INSTR(input_string, key_value_delimiter)<span class="number">-1</span>) <span class="keyword">AS</span> key,</span><br><span class="line">               SUBSTR(input_string, INSTR(input_string, key_value_delimiter)<span class="operator">+</span><span class="number">1</span>) <span class="keyword">AS</span> <span class="keyword">value</span></span><br><span class="line">          <span class="keyword">FROM</span> (</span><br><span class="line">               <span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(REGEXP_SUBSTR(input_string, <span class="string">&#x27;[^&#x27;</span> <span class="operator">||</span> delimiter <span class="operator">||</span> <span class="string">&#x27;]+&#x27;</span>, <span class="number">1</span>, LEVEL)) <span class="keyword">AS</span> input_string</span><br><span class="line">                 <span class="keyword">FROM</span> DUAL</span><br><span class="line">           <span class="keyword">CONNECT</span> <span class="keyword">BY</span> LEVEL <span class="operator">&lt;=</span> REGEXP_COUNT(input_string, <span class="string">&#x27;[^&#x27;</span> <span class="operator">||</span> delimiter <span class="operator">||</span> <span class="string">&#x27;]+&#x27;</span>)</span><br><span class="line">               )</span><br><span class="line">         <span class="keyword">WHERE</span> input_string <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">RETURN</span> output_cursor;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>利用这个函数可以返回一个’SYS_REFCURSOR’类型的游标，其中包含两列，一列为键，一列为值，游标可以使用 SELECT 语句来读取。</p><h3 id="2-在存储过程或者命令行用游标对其进行读取"><a href="#2-在存储过程或者命令行用游标对其进行读取" class="headerlink" title="2.在存储过程或者命令行用游标对其进行读取"></a>2.在存储过程或者命令行用游标对其进行读取</h3><p>基本上都是在存储过程了，命令行就用来测试测试效果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  output_cur SYS_REFCURSOR;</span><br><span class="line">  key_value_pair VARCHAR2(<span class="number">30000</span>) ;</span><br><span class="line">  output_key VARCHAR2(<span class="number">4000</span>);</span><br><span class="line">  output_value VARCHAR2(<span class="number">4000</span>);</span><br><span class="line">  v_key_p VARCHAR2(<span class="number">4000</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> cur <span class="keyword">IN</span> </span><br><span class="line">      (<span class="keyword">SELECT</span>  KEY_P,KPI_1,KPI_2 <span class="keyword">FROM</span> DEMO1 <span class="comment">--WHERE  可能有其他的限制条件</span></span><br><span class="line">      )   </span><br><span class="line">    LOOP</span><br><span class="line">      key_value_pair :<span class="operator">=</span> cur.KPI_1 <span class="operator">||</span> cur.KPI_2;</span><br><span class="line">      v_key_p :<span class="operator">=</span> cur.KEY_P;</span><br><span class="line">      output_cur :<span class="operator">=</span> split_key_value_pairs(key_value_pair);</span><br><span class="line">        LOOP</span><br><span class="line">            <span class="keyword">FETCH</span> output_cur <span class="keyword">INTO</span> output_key, output_value;</span><br><span class="line">            EXIT <span class="keyword">WHEN</span> output_cur<span class="operator">%</span>NOTFOUND;</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> DEMO1_MID</span><br><span class="line">            <span class="keyword">VALUES</span> </span><br><span class="line">            (</span><br><span class="line">            v_key_p,</span><br><span class="line">            output_key,</span><br><span class="line">            output_value</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">END</span> LOOP;</span><br><span class="line">        <span class="keyword">CLOSE</span> output_cur;</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用了双循环，先在DEMO1里面一次扫描每一行，将KPI_1,KPI_2进行拼接利用函数拆分，写进中间表DEMO1_MID<br>最后的数据结果就是酱紫：</p><table><thead><tr><th align="center">KEY_P</th><th align="center">KEY_</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">INDEX_1</td><td align="center">10</td></tr><tr><td align="center">A</td><td align="center">INDEX_2</td><td align="center">20</td></tr><tr><td align="center">A</td><td align="center">INDEX_3</td><td align="center">30</td></tr><tr><td align="center">B</td><td align="center">INDEX_4</td><td align="center">40</td></tr><tr><td align="center">B</td><td align="center">INDEX_5</td><td align="center">50</td></tr><tr><td align="center">B</td><td align="center">INDEX_6</td><td align="center">60</td></tr></tbody></table><p>这样，设备以及各个端口数据就可以进行下一步操作了👀</p>]]></content>
      
      
      <categories>
          
          <category> ORACLE </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 个人信息卡片背景图 */[data-theme="light"] #aside-content > .card-widget.card-info {    background-image: url(https://sourcebucket.s3.ladydaily.com/img/snowflower.webp);    background-repeat: no-repeat;    background-attachment: inherit;    background-size: 100%;  }  [data-theme="dark"] #aside-content > .card-widget.card-info {    background-image: url(https://sourcebucket.s3.ladydaily.com/img/aurora.webp);    background-repeat: no-repeat;    background-attachment: inherit;    background-size: 100%;  }/*导航栏修改*//* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -30px;}  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
